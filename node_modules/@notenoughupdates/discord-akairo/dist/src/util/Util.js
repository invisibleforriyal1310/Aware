"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.patchAbstract = exports.isStringArrayStringOrFunc = exports.isArrayOf = exports.pascalToCamelCase = exports.snakeToCamelCase = exports.deepEquals = exports.prefixCompare = exports.isPromise = exports.isEventEmitter = exports.intoCallable = exports.intoArray = exports.deepAssign = void 0;
const node_events_1 = __importDefault(require("node:events"));
const node_util_1 = __importDefault(require("node:util"));
const AkairoError_js_1 = require("./AkairoError.js");
function deepAssign(target, ...os) {
    for (const o of os) {
        for (const [key, value] of Object.entries(o)) {
            const valueIsObject = value && typeof value === "object";
            const targetKeyIsObject = Object.prototype.hasOwnProperty.call(target, key) &&
                target[key] &&
                typeof target[key] === "object";
            if (valueIsObject && targetKeyIsObject) {
                deepAssign(target[key], value);
            }
            else {
                target[key] = value;
            }
        }
    }
    return target;
}
exports.deepAssign = deepAssign;
function intoArray(x) {
    if (Array.isArray(x)) {
        return x;
    }
    return [x];
}
exports.intoArray = intoArray;
function intoCallable(thing) {
    if (typeof thing === "function") {
        return thing;
    }
    return () => thing;
}
exports.intoCallable = intoCallable;
function isEventEmitter(value) {
    return value instanceof node_events_1.default;
}
exports.isEventEmitter = isEventEmitter;
function isPromise(value) {
    return node_util_1.default.types.isPromise(value);
}
exports.isPromise = isPromise;
function prefixCompare(aKey, bKey) {
    if (aKey === "" && bKey === "")
        return 0;
    if (aKey === "")
        return 1;
    if (bKey === "")
        return -1;
    if (typeof aKey === "function" && typeof bKey === "function")
        return 0;
    if (typeof aKey === "function")
        return 1;
    if (typeof bKey === "function")
        return -1;
    return aKey.length === bKey.length ? aKey.localeCompare(bKey) : bKey.length - aKey.length;
}
exports.prefixCompare = prefixCompare;
function deepEquals(a, b, options) {
    const { ignoreUndefined = true, ignoreArrayOrder = true } = options ?? {};
    if (Object.is(a, b))
        return true;
    else if ((typeof a !== "object" || a === null) && (typeof b !== "object" || b === null))
        return false;
    else if (typeof a !== typeof b && (typeof a === "object" || typeof b === "object"))
        return false;
    else if (typeof a === typeof b && (a === null || b === null))
        return false;
    if (typeof a !== "object" || typeof b !== "object")
        throw new TypeError("Not objects");
    if ((Array.isArray(a) && !Array.isArray(b)) || (!Array.isArray(a) && Array.isArray(b)))
        return false;
    const newA = ignoreArrayOrder && Array.isArray(a) && a.length && typeof a[0] !== "object" ? [...a].sort() : a;
    const newB = ignoreArrayOrder && Array.isArray(b) && b.length && typeof b[0] !== "object" ? [...b].sort() : b;
    for (const key in newA) {
        if (ignoreUndefined && newA[key] === undefined && newB[key] === undefined)
            continue;
        if (!(key in newB))
            return false;
        if (typeof newA[key] === "object" && typeof newB[key] === "object") {
            if (!deepEquals(newA[key], newB[key], { ignoreUndefined, ignoreArrayOrder }))
                return false;
        }
        else if (newA[key] !== newB[key])
            return false;
    }
    for (const key in newB) {
        if (ignoreUndefined && newA[key] === undefined && newB[key] === undefined)
            continue;
        if (!(key in newA))
            return false;
        if (typeof newB[key] === "object" && typeof newA[key] === "object") {
            if (!deepEquals(newA[key], newB[key], { ignoreUndefined, ignoreArrayOrder }))
                return false;
        }
        else if (newA[key] !== newB[key])
            return false;
    }
    return true;
}
exports.deepEquals = deepEquals;
function snakeToCamelCase(str) {
    return str
        .toLowerCase()
        .split("_")
        .map((word, index) => {
        if (index !== 0)
            return word.charAt(0).toUpperCase() + word.slice(1);
        return word;
    })
        .join("");
}
exports.snakeToCamelCase = snakeToCamelCase;
function pascalToCamelCase(str) {
    return str.charAt(0).toLowerCase() + str.slice(1);
}
exports.pascalToCamelCase = pascalToCamelCase;
function isArrayOf(array, type) {
    if (!Array.isArray(array))
        return false;
    return array.every(item => typeof item === type);
}
exports.isArrayOf = isArrayOf;
function isStringArrayStringOrFunc(value) {
    return typeof value === "string" || typeof value === "function" || isArrayOf(value, "string");
}
exports.isStringArrayStringOrFunc = isStringArrayStringOrFunc;
function patchAbstract(Class, method) {
    Object.defineProperty(Class.prototype, method, {
        configurable: true,
        enumerable: false,
        writable: true,
        value: function () {
            throw new AkairoError_js_1.AkairoError("NOT_IMPLEMENTED", this.constructor.name, method);
        }
    });
}
exports.patchAbstract = patchAbstract;
//# sourceMappingURL=Util.js.map