import EventEmitter from "node:events";
import type { PrefixSupplier } from "../struct/commands/CommandHandler.js";
import { SyncOrAsync } from "../typings/Util.js";
export declare function deepAssign<A extends Record<string, any>, B extends Record<string, any>>(target: A, ...os: B[]): A & B;
export declare function intoArray<T>(x: T | T[]): T[];
export declare function intoCallable<T>(thing: T | ((...args: any[]) => T)): (...args: any[]) => T;
export declare function isEventEmitter(value: unknown): value is EventEmitter;
export declare function isPromise<T>(value: SyncOrAsync<T>): value is Promise<T>;
export declare function prefixCompare(aKey: string | PrefixSupplier, bKey: string | PrefixSupplier): number;
export declare function deepEquals<T>(a: unknown, b: T, options?: DeepEqualsOptions): a is T;
export interface DeepEqualsOptions {
    ignoreUndefined?: boolean;
    ignoreArrayOrder?: boolean;
}
export declare function snakeToCamelCase(str: string): string;
export declare function pascalToCamelCase(str: string): string;
export declare function isArrayOf<T>(array: T[], type: "string" | "number" | "bigint" | "boolean" | "symbol" | "undefined" | "object" | "function"): boolean;
export declare function isStringArrayStringOrFunc(value: any): value is string | string[] | ((...args: any[]) => any);
export declare function patchAbstract(Class: Function, method: string): void;
type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;
export type PartialBy<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;
export {};
//# sourceMappingURL=Util.d.ts.map