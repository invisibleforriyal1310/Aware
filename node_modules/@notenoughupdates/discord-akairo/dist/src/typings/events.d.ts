import type { ChatInputCommandInteraction, ClientEvents, ContextMenuCommandInteraction, Message } from "discord.js";
import type { AkairoHandler } from "../struct/AkairoHandler.js";
import type { AkairoModule } from "../struct/AkairoModule.js";
import type { Command } from "../struct/commands/Command.js";
import type { CommandHandler } from "../struct/commands/CommandHandler.js";
import type { ContextMenuCommand } from "../struct/contextMenuCommands/ContextMenuCommand.js";
import type { ContextMenuCommandHandler } from "../struct/contextMenuCommands/ContextMenuCommandHandler.js";
import type { Inhibitor } from "../struct/inhibitors/Inhibitor.js";
import type { InhibitorHandler } from "../struct/inhibitors/InhibitorHandler.js";
import type { Listener } from "../struct/listeners/Listener.js";
import type { ListenerHandler } from "../struct/listeners/ListenerHandler.js";
import type { Task } from "../struct/tasks/Task.js";
import type { TaskHandler } from "../struct/tasks/TaskHandler.js";
import type { AkairoMessage } from "../util/AkairoMessage.js";
import type { BuiltInReasons } from "../util/Constants.js";
export interface AkairoHandlerEvents<Module extends AkairoModule<Handler, Module>, Handler extends AkairoHandler<Module, Handler>> {
    load: [mod: Module, isReload: boolean];
    remove: [mod: Module];
}
export interface CommandHandlerEvents extends AkairoHandlerEvents<Command, CommandHandler> {
    commandBlocked: [message: Message, command: Command, reason: typeof BuiltInReasons | string];
    commandBreakout: [message: Message, command: Command, breakMessage: Message];
    commandCancelled: [message: Message, command: Command, retryMessage?: Message];
    commandTimeout: [message: Message, command: Command, time: number];
    commandFinished: [message: Message, command: Command, args: any, returnValue: any];
    commandInvalid: [message: Message, command: Command];
    commandLocked: [message: Message, command: Command];
    commandStarted: [message: Message, command: Command, args: any];
    cooldown: [message: Message | AkairoMessage, command: Command, remaining: number];
    error: [error: Error, message: Message, command?: Command];
    inPrompt: [message: Message];
    messageBlocked: [message: Message | AkairoMessage, reason: string];
    messageInvalid: [message: Message];
    missingPermissions: [message: Message, command: Command, type: "client" | "user", missing?: any];
    slashBlocked: [message: AkairoMessage, command: Command, reason: string];
    slashError: [error: Error, message: AkairoMessage, command: Command];
    slashFinished: [message: AkairoMessage, command: Command, args: any, returnValue: any];
    slashMissingPermissions: [message: AkairoMessage, command: Command, type: "user" | "client", missing?: any];
    slashNotFound: [interaction: ChatInputCommandInteraction];
    slashStarted: [message: AkairoMessage, command: Command, args: any];
    slashOnly: [message: Message, command: Command];
}
export interface InhibitorHandlerEvents extends AkairoHandlerEvents<Inhibitor, InhibitorHandler> {
}
export interface ListenerHandlerEvents extends AkairoHandlerEvents<Listener, ListenerHandler> {
}
export interface TaskHandlerEvents extends AkairoHandlerEvents<Task, TaskHandler> {
}
export interface ContextMenuCommandHandlerEvents extends AkairoHandlerEvents<ContextMenuCommand, ContextMenuCommandHandler> {
    error: [error: Error, interaction: ContextMenuCommandInteraction, command: ContextMenuCommand];
    finished: [interaction: ContextMenuCommandInteraction, command: ContextMenuCommand, returnValue: any];
    notFound: [interaction: ContextMenuCommandInteraction];
    started: [interaction: ContextMenuCommandInteraction, command: ContextMenuCommand];
    blocked: [
        interaction: ContextMenuCommandInteraction,
        command: Command,
        reason: typeof BuiltInReasons.OWNER | typeof BuiltInReasons.SUPER_USER
    ];
}
export interface AkairoClientEvents extends ClientEvents {
    akairoDebug: [message: string, ...other: any[]];
}
//# sourceMappingURL=events.d.ts.map