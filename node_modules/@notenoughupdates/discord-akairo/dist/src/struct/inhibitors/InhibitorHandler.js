"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InhibitorHandler = void 0;
const AkairoError_js_1 = require("../../util/AkairoError.js");
const Util_js_1 = require("../../util/Util.js");
const AkairoHandler_js_1 = require("../AkairoHandler.js");
const Inhibitor_js_1 = require("./Inhibitor.js");
class InhibitorHandler extends AkairoHandler_js_1.AkairoHandler {
    constructor(client, options) {
        const { directory, classToHandle = Inhibitor_js_1.Inhibitor, extensions = [".js", ".ts"], automateCategories, loadFilter } = options;
        if (!(classToHandle.prototype instanceof Inhibitor_js_1.Inhibitor || classToHandle === Inhibitor_js_1.Inhibitor)) {
            throw new AkairoError_js_1.AkairoError("INVALID_CLASS_TO_HANDLE", classToHandle.name, Inhibitor_js_1.Inhibitor.name);
        }
        super(client, { directory, classToHandle, extensions, automateCategories, loadFilter });
    }
    async test(type, message, command) {
        if (!this.modules.size)
            return null;
        const inhibitors = this.modules.filter(i => i.type === type);
        if (!inhibitors.size)
            return null;
        const promises = [];
        for (const inhibitor of inhibitors.values()) {
            promises.push((async () => {
                let inhibited = inhibitor.exec(message, command);
                if ((0, Util_js_1.isPromise)(inhibited))
                    inhibited = await inhibited;
                if (inhibited)
                    return inhibitor;
                return null;
            })());
        }
        const inhibitedInhibitors = (await Promise.all(promises)).filter(r => r);
        if (!inhibitedInhibitors.length)
            return null;
        inhibitedInhibitors.sort((a, b) => b.priority - a.priority);
        return inhibitedInhibitors[0].reason;
    }
}
exports.InhibitorHandler = InhibitorHandler;
//# sourceMappingURL=InhibitorHandler.js.map