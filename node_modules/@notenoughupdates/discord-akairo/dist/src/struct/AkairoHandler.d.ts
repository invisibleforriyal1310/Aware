import { Collection } from "discord.js";
import EventEmitter from "node:events";
import { z } from "zod";
import { Category } from "../util/Category.js";
import { AkairoClient } from "./AkairoClient.js";
import { AkairoModule } from "./AkairoModule.js";
export type Class<T> = abstract new (...args: any[]) => T;
export declare class AkairoHandler<Module extends AkairoModule<Handler, Module>, Handler extends AkairoHandler<Module, Handler>> extends EventEmitter {
    automateCategories: boolean;
    categories: Collection<string, Category<string, Module>>;
    classToHandle: Class<Module>;
    client: AkairoClient;
    directory: string;
    extensions: Set<Extension>;
    loadFilter: LoadPredicate;
    modules: Collection<string, Module>;
    constructor(client: AkairoClient, options: AkairoHandlerOptions<Module, Handler>);
    deregister(mod: Module): void;
    findCategory(name: string): Category<string, Module> | undefined;
    load(thing: string | Module, isReload?: boolean): Promise<Module | undefined>;
    loadAll(directory?: string, filter?: LoadPredicate): Promise<this>;
    register(mod: Module, filepath?: string): void;
    reload(id: string): Promise<Module | undefined>;
    reloadAll(): Promise<this>;
    remove(id: string): Module;
    removeAll(): this;
    static readdirRecursive(directory: string): string[];
}
export type LoadPredicate = (filepath: string) => boolean;
export declare const LoadPredicate: z.ZodFunction<z.ZodTuple<[z.ZodString], z.ZodUnknown>, z.ZodBoolean>;
export type Extension = `.${string}` | string;
export declare const Extension: z.ZodString;
export type AkairoHandlerOptions<Module extends AkairoModule<Handler, Module>, Handler extends AkairoHandler<Module, Handler>> = {
    automateCategories?: boolean;
    classToHandle?: Class<Module>;
    directory: string;
    extensions?: Extension[] | Set<Extension>;
    loadFilter?: LoadPredicate;
};
export declare const AkairoHandlerOptions: z.ZodObject<{
    automateCategories: z.ZodOptional<z.ZodBoolean>;
    classToHandle: z.ZodAny;
    directory: z.ZodString;
    extensions: z.ZodOptional<z.ZodUnion<[z.ZodArray<z.ZodString, "many">, z.ZodSet<z.ZodString>]>>;
    loadFilter: z.ZodOptional<z.ZodFunction<z.ZodTuple<[z.ZodString], z.ZodUnknown>, z.ZodBoolean>>;
}, "passthrough", z.ZodTypeAny, z.objectOutputType<{
    automateCategories: z.ZodOptional<z.ZodBoolean>;
    classToHandle: z.ZodAny;
    directory: z.ZodString;
    extensions: z.ZodOptional<z.ZodUnion<[z.ZodArray<z.ZodString, "many">, z.ZodSet<z.ZodString>]>>;
    loadFilter: z.ZodOptional<z.ZodFunction<z.ZodTuple<[z.ZodString], z.ZodUnknown>, z.ZodBoolean>>;
}, z.ZodTypeAny, "passthrough">, z.objectInputType<{
    automateCategories: z.ZodOptional<z.ZodBoolean>;
    classToHandle: z.ZodAny;
    directory: z.ZodString;
    extensions: z.ZodOptional<z.ZodUnion<[z.ZodArray<z.ZodString, "many">, z.ZodSet<z.ZodString>]>>;
    loadFilter: z.ZodOptional<z.ZodFunction<z.ZodTuple<[z.ZodString], z.ZodUnknown>, z.ZodBoolean>>;
}, z.ZodTypeAny, "passthrough">>;
//# sourceMappingURL=AkairoHandler.d.ts.map