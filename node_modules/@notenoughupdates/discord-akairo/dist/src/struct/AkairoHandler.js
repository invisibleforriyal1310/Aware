"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AkairoHandlerOptions = exports.Extension = exports.LoadPredicate = exports.AkairoHandler = void 0;
const discord_js_1 = require("discord.js");
const node_events_1 = __importDefault(require("node:events"));
const node_fs_1 = require("node:fs");
const node_path_1 = require("node:path");
const node_url_1 = require("node:url");
const zod_1 = require("zod");
const AkairoError_js_1 = require("../util/AkairoError.js");
const Category_js_1 = require("../util/Category.js");
const Constants_js_1 = require("../util/Constants.js");
const AkairoClient_js_1 = require("./AkairoClient.js");
const AkairoModule_js_1 = require("./AkairoModule.js");
class AkairoHandler extends node_events_1.default {
    constructor(client, options) {
        zod_1.z.instanceof(AkairoClient_js_1.AkairoClient).parse(client);
        exports.AkairoHandlerOptions.parse(options);
        const { automateCategories = false, classToHandle = AkairoModule_js_1.AkairoModule, directory, extensions = [".js", ".json", ".ts"], loadFilter = () => true } = options;
        super();
        this.client = client;
        this.directory = directory;
        this.classToHandle = classToHandle;
        this.extensions = new Set(extensions);
        this.automateCategories = automateCategories;
        this.loadFilter = loadFilter;
        this.modules = new discord_js_1.Collection();
        this.categories = new discord_js_1.Collection();
    }
    deregister(mod) {
        if (mod.filepath)
            delete require.cache[require.resolve(mod.filepath)];
        this.modules.delete(mod.id);
        mod.category.delete(mod.id);
    }
    findCategory(name) {
        return this.categories.find(category => {
            return category.id.toLowerCase() === name.toLowerCase();
        });
    }
    async load(thing, isReload = false) {
        const isClass = typeof thing === "function";
        if (!isClass && !this.extensions.has((0, node_path_1.extname)(thing)))
            return undefined;
        let mod = isClass
            ? thing
            : function findExport(m) {
                if (!m)
                    return null;
                if (m.prototype instanceof this.classToHandle)
                    return m;
                return m.default ? findExport.call(this, m.default) : null;
            }.call(this, await eval(`import(${JSON.stringify(`${(0, node_url_1.pathToFileURL)(thing).toString()}?update=${Date.now()}`)})`));
        if (mod && mod.prototype instanceof this.classToHandle) {
            mod = new mod(this);
        }
        else {
            if (!isClass)
                delete require.cache[require.resolve(thing)];
            return undefined;
        }
        if (this.modules.has(mod.id))
            throw new AkairoError_js_1.AkairoError("ALREADY_LOADED", this.classToHandle.name, mod.id);
        this.register(mod, isClass ? null : thing);
        this.emit(Constants_js_1.AkairoHandlerEvents.LOAD, mod, isReload);
        return mod;
    }
    async loadAll(directory = this.directory, filter = this.loadFilter || (() => true)) {
        const filepaths = AkairoHandler.readdirRecursive(directory);
        const promises = [];
        for (let filepath of filepaths) {
            filepath = (0, node_path_1.resolve)(filepath);
            if (filter(filepath))
                promises.push(this.load(filepath));
        }
        await Promise.all(promises);
        return this;
    }
    register(mod, filepath) {
        mod.filepath = filepath;
        mod.client = this.client;
        mod.handler = this;
        this.modules.set(mod.id, mod);
        if (mod.categoryID === "default" && this.automateCategories) {
            const dirs = (0, node_path_1.dirname)(filepath).split(node_path_1.sep);
            mod.categoryID = dirs[dirs.length - 1];
        }
        if (!this.categories.has(mod.categoryID)) {
            this.categories.set(mod.categoryID, new Category_js_1.Category(mod.categoryID));
        }
        const category = this.categories.get(mod.categoryID);
        mod.category = category;
        category.set(mod.id, mod);
    }
    async reload(id) {
        const mod = this.modules.get(id.toString());
        if (!mod)
            throw new AkairoError_js_1.AkairoError("MODULE_NOT_FOUND", this.classToHandle.name, id);
        if (!mod.filepath)
            throw new AkairoError_js_1.AkairoError("NOT_RELOADABLE", this.classToHandle.name, id);
        this.deregister(mod);
        const filepath = mod.filepath;
        const newMod = await this.load(filepath, true);
        return newMod;
    }
    async reloadAll() {
        const promises = [];
        for (const m of Array.from(this.modules.values())) {
            if (m.filepath)
                promises.push(this.reload(m.id));
        }
        await Promise.all(promises);
        return this;
    }
    remove(id) {
        const mod = this.modules.get(id.toString());
        if (!mod)
            throw new AkairoError_js_1.AkairoError("MODULE_NOT_FOUND", this.classToHandle.name, id);
        this.deregister(mod);
        this.emit(Constants_js_1.AkairoHandlerEvents.REMOVE, mod);
        return mod;
    }
    removeAll() {
        for (const m of Array.from(this.modules.values())) {
            if (m.filepath)
                this.remove(m.id);
        }
        return this;
    }
    static readdirRecursive(directory) {
        const result = [];
        (function read(dir) {
            const files = (0, node_fs_1.readdirSync)(dir);
            for (const file of files) {
                const filepath = (0, node_path_1.join)(dir, file);
                if ((0, node_fs_1.statSync)(filepath).isDirectory()) {
                    read(filepath);
                }
                else {
                    result.push(filepath);
                }
            }
        })(directory);
        return result;
    }
}
exports.AkairoHandler = AkairoHandler;
exports.LoadPredicate = zod_1.z.function().args(zod_1.z.string()).returns(zod_1.z.boolean());
exports.Extension = zod_1.z.string().regex(/\..*$/);
exports.AkairoHandlerOptions = zod_1.z
    .object({
    automateCategories: zod_1.z.boolean().optional(),
    classToHandle: zod_1.z.any(),
    directory: zod_1.z.string(),
    extensions: zod_1.z.union([exports.Extension.array(), zod_1.z.set(exports.Extension)]).optional(),
    loadFilter: exports.LoadPredicate.optional()
})
    .passthrough();
//# sourceMappingURL=AkairoHandler.js.map