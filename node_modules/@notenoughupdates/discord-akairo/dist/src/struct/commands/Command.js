"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CommandInstance = exports.CommandOptions = exports.RegexSupplier = exports.KeySupplier = exports.ExecutionPredicate = exports.MissingPermissionSupplier = exports.BeforeAction = exports.ArgumentGenerator = exports.CommandArguments = exports.Command = void 0;
const zod_1 = require("zod");
const Util_js_1 = require("../../typings/Util.js");
const AkairoMessage_js_1 = require("../../util/AkairoMessage.js");
const Util_js_2 = require("../../util/Util.js");
const AkairoModule_js_1 = require("../AkairoModule.js");
const Argument_js_1 = require("./arguments/Argument.js");
const ArgumentRunner_js_1 = require("./arguments/ArgumentRunner.js");
const CommandHandler_js_1 = require("./CommandHandler.js");
const ContentParser_js_1 = require("./ContentParser.js");
class Command extends AkairoModule_js_1.AkairoModule {
    constructor(id, options = {}) {
        super(id, { category: options?.category });
        exports.CommandOptions.parse(options);
        const { aliases = [], args = this.args || [], argumentDefaults = {}, before = this.before || (() => undefined), channel = null, clientPermissions = this.clientPermissions, condition = this.condition || (() => false), cooldown = null, description = "", editable = true, flags = [], ignoreCooldown, ignorePermissions, localization = {}, lock, onlyNsfw = false, optionFlags = [], ownerOnly = false, prefix = this.prefix, quoted = true, ratelimit = 1, regex = this.regex, separator, slash = false, slashEphemeral = false, slashGuilds = [], slashOnly = false, slashOptions, superUserOnly = false, typing = false, userPermissions = this.userPermissions, slashDefaultMemberPermissions } = options;
        let { slashDmPermission } = options;
        if (slashGuilds.length === 0)
            slashDmPermission ??= channel === null || channel === "dm";
        this.aliases = aliases;
        const { flagWords, optionFlagWords } = Array.isArray(args)
            ? ContentParser_js_1.ContentParser.getFlags(args)
            : { flagWords: flags, optionFlagWords: optionFlags };
        this.contentParser = new ContentParser_js_1.ContentParser({
            flagWords,
            optionFlagWords,
            quoted,
            separator
        });
        this.argumentRunner = new ArgumentRunner_js_1.ArgumentRunner(this);
        this.argumentGenerator = Array.isArray(args)
            ? ArgumentRunner_js_1.ArgumentRunner.fromArguments(args.map(arg => [arg.id, new Argument_js_1.Argument(this, arg)]))
            : args.bind(this);
        this.argumentDefaults = argumentDefaults;
        this.before = before.bind(this);
        this.channel = channel;
        this.clientPermissions = typeof clientPermissions === "function" ? clientPermissions.bind(this) : clientPermissions;
        this.condition = condition.bind(this);
        this.cooldown = cooldown;
        this.description = Array.isArray(description) ? description.join("\n") : description;
        this.editable = editable;
        this.localization = localization;
        this.onlyNsfw = Boolean(onlyNsfw);
        this.ownerOnly = Boolean(ownerOnly);
        this.superUserOnly = Boolean(superUserOnly);
        this.prefix = typeof prefix === "function" ? prefix.bind(this) : prefix;
        this.ratelimit = ratelimit;
        this.regex = typeof regex === "function" ? regex.bind(this) : regex;
        this.typing = Boolean(typing);
        this.userPermissions = typeof userPermissions === "function" ? userPermissions.bind(this) : userPermissions;
        this.lock =
            typeof lock === "string"
                ? {
                    guild: (message) => message.guild && message.guild.id,
                    channel: (message) => message.channel.id,
                    user: (message) => message.author.id
                }[lock]
                : lock;
        if (this.lock)
            this.locker = new Set();
        this.ignoreCooldown = typeof ignoreCooldown === "function" ? ignoreCooldown.bind(this) : ignoreCooldown;
        this.ignorePermissions = typeof ignorePermissions === "function" ? ignorePermissions.bind(this) : ignorePermissions;
        this.slash = slash;
        this.slashDefaultMemberPermissions = slashDefaultMemberPermissions;
        this.slashDmPermission = slashDmPermission;
        this.slashEphemeral = slashEphemeral;
        this.slashGuilds = slashGuilds;
        this.slashOnly = slashOnly;
        this.slashOptions = slashOptions;
    }
    parse(message, content) {
        const parsed = this.contentParser.parse(content);
        return this.argumentRunner.run(message, parsed, this.argumentGenerator);
    }
}
exports.Command = Command;
(0, Util_js_2.patchAbstract)(Command, "exec");
(0, Util_js_2.patchAbstract)(Command, "execSlash");
(0, Util_js_2.patchAbstract)(Command, "autocomplete");
exports.CommandArguments = zod_1.z.record(zod_1.z.any());
exports.ArgumentGenerator = zod_1.z.function().args(Util_js_1.MessageInstance, ContentParser_js_1.ContentParserResult, ArgumentRunner_js_1.ArgumentRunnerState).returns(zod_1.z.any());
exports.BeforeAction = zod_1.z.function().args(Util_js_1.MessageInstance).returns(zod_1.z.any());
exports.MissingPermissionSupplier = zod_1.z
    .function()
    .args(zod_1.z.union([Util_js_1.MessageInstance, zod_1.z.instanceof(AkairoMessage_js_1.AkairoMessage)]))
    .returns((0, Util_js_1.SyncOrAsync)(zod_1.z.any()));
exports.ExecutionPredicate = zod_1.z.function().args(Util_js_1.MessageInstance).returns((0, Util_js_1.SyncOrAsync)(zod_1.z.boolean()));
exports.KeySupplier = zod_1.z
    .function()
    .args(zod_1.z.union([Util_js_1.MessageInstance, zod_1.z.instanceof(AkairoMessage_js_1.AkairoMessage)]), exports.CommandArguments)
    .returns(zod_1.z.string());
exports.RegexSupplier = zod_1.z.function().args(Util_js_1.MessageInstance).returns(zod_1.z.instanceof(RegExp));
exports.CommandOptions = AkairoModule_js_1.AkairoModuleOptions.extend({
    aliases: zod_1.z.string().array().optional(),
    args: zod_1.z.union([Argument_js_1.ArgumentOptions.array(), exports.ArgumentGenerator]).optional(),
    argumentDefaults: Argument_js_1.DefaultArgumentOptions.optional(),
    before: exports.BeforeAction.optional(),
    channel: zod_1.z.enum(["guild", "dm"]).nullish(),
    clientPermissions: zod_1.z.union([Util_js_1.PermissionResolvableValidator, exports.MissingPermissionSupplier]).optional(),
    condition: exports.ExecutionPredicate.optional(),
    cooldown: zod_1.z.number().nullish(),
    description: zod_1.z.union([zod_1.z.string(), (0, Util_js_1.ArrayOrNot)(zod_1.z.any())]).optional(),
    editable: zod_1.z.boolean().optional(),
    flags: zod_1.z.string().array().optional(),
    ignoreCooldown: zod_1.z.union([(0, Util_js_1.ArrayOrNot)(zod_1.z.string()), CommandHandler_js_1.IgnoreCheckPredicate]).optional(),
    ignorePermissions: zod_1.z.union([(0, Util_js_1.ArrayOrNot)(zod_1.z.string()), CommandHandler_js_1.IgnoreCheckPredicate]).optional(),
    localization: zod_1.z.record(zod_1.z.any()).optional(),
    lock: zod_1.z.union([exports.KeySupplier, zod_1.z.enum(["guild", "channel", "user"])]).optional(),
    onlyNsfw: zod_1.z.boolean().optional(),
    optionFlags: zod_1.z.string().array().optional(),
    ownerOnly: zod_1.z.boolean().optional(),
    prefix: zod_1.z.union([(0, Util_js_1.ArrayOrNot)(zod_1.z.string()), CommandHandler_js_1.PrefixSupplier]).optional(),
    quoted: zod_1.z.boolean().optional(),
    ratelimit: zod_1.z.number().optional(),
    regex: zod_1.z.union([zod_1.z.instanceof(RegExp), exports.RegexSupplier]).optional(),
    separator: zod_1.z.string().optional(),
    slash: zod_1.z.boolean().optional(),
    slashDefaultMemberPermissions: Util_js_1.PermissionResolvableValidator.nullish(),
    slashDmPermission: zod_1.z.boolean().optional(),
    slashEphemeral: zod_1.z.boolean().optional(),
    slashGuilds: zod_1.z.string().array().optional(),
    slashOptions: zod_1.z.any().array().optional(),
    slashOnly: zod_1.z.boolean().optional(),
    superUserOnly: zod_1.z.boolean().optional(),
    typing: zod_1.z.boolean().optional(),
    userPermissions: zod_1.z.union([Util_js_1.PermissionResolvableValidator, exports.MissingPermissionSupplier]).optional()
}).passthrough();
exports.CommandInstance = zod_1.z.instanceof(Command);
//# sourceMappingURL=Command.js.map