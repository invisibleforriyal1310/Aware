"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ArgumentRunnerState = exports.ArgumentRunner = void 0;
const zod_1 = require("zod");
const AkairoError_js_1 = require("../../../util/AkairoError.js");
const Constants_js_1 = require("../../../util/Constants.js");
const Flag_js_1 = require("../Flag.js");
const Argument_js_1 = require("./Argument.js");
class ArgumentRunner {
    constructor(command) {
        this.command = command;
    }
    get client() {
        return this.command.client;
    }
    get handler() {
        return this.command.handler;
    }
    async run(message, parsed, generator) {
        const state = {
            usedIndices: new Set(),
            phraseIndex: 0,
            index: 0
        };
        const augmentRest = (val) => {
            if (Flag_js_1.Flag.is(val, Flag_js_1.FlagType.Continue)) {
                val.rest = parsed.all
                    .slice(state.index)
                    .map(x => x.raw)
                    .join("");
            }
        };
        const iter = generator(message, parsed, state);
        let curr = await iter.next();
        while (!curr.done) {
            const value = curr.value;
            if (ArgumentRunner.isShortCircuit(value)) {
                augmentRest(value);
                return value;
            }
            const res = await this.runOne(message, parsed, state, new Argument_js_1.Argument(this.command, value));
            if (ArgumentRunner.isShortCircuit(res)) {
                augmentRest(res);
                return res;
            }
            curr = await iter.next(res);
        }
        augmentRest(curr.value);
        return curr.value;
    }
    runOne(message, parsed, state, arg) {
        const cases = {
            [Constants_js_1.ArgumentMatches.PHRASE]: this.runPhrase,
            [Constants_js_1.ArgumentMatches.FLAG]: this.runFlag,
            [Constants_js_1.ArgumentMatches.OPTION]: this.runOption,
            [Constants_js_1.ArgumentMatches.REST]: this.runRest,
            [Constants_js_1.ArgumentMatches.SEPARATE]: this.runSeparate,
            [Constants_js_1.ArgumentMatches.TEXT]: this.runText,
            [Constants_js_1.ArgumentMatches.CONTENT]: this.runContent,
            [Constants_js_1.ArgumentMatches.REST_CONTENT]: this.runRestContent,
            [Constants_js_1.ArgumentMatches.NONE]: this.runNone
        };
        const runFn = cases[arg.match];
        if (runFn == null) {
            throw new AkairoError_js_1.AkairoError("UNKNOWN_MATCH_TYPE", arg.match);
        }
        return runFn.call(this, message, parsed, state, arg);
    }
    async runPhrase(message, parsed, state, arg) {
        if (arg.unordered || arg.unordered === 0) {
            const indices = typeof arg.unordered === "number"
                ? Array.from(parsed.phrases.keys()).slice(arg.unordered)
                : Array.isArray(arg.unordered)
                    ? arg.unordered
                    : Array.from(parsed.phrases.keys());
            for (const i of indices) {
                if (state.usedIndices.has(i)) {
                    continue;
                }
                const phrase = parsed.phrases[i] ? parsed.phrases[i].value : "";
                const res = await arg.cast(message, phrase);
                if (res != null) {
                    state.usedIndices.add(i);
                    return res;
                }
            }
            return arg.process(message, "");
        }
        const index = arg.index == null ? state.phraseIndex : arg.index;
        const ret = arg.process(message, parsed.phrases[index] ? parsed.phrases[index].value : "");
        if (arg.index == null) {
            ArgumentRunner.increaseIndex(parsed, state);
        }
        return ret;
    }
    async runRest(message, parsed, state, arg) {
        const index = arg.index == null ? state.phraseIndex : arg.index;
        const rest = parsed.phrases
            .slice(index, index + arg.limit)
            .map(x => x.raw)
            .join("")
            .trim();
        const ret = await arg.process(message, rest);
        if (arg.index == null) {
            ArgumentRunner.increaseIndex(parsed, state);
        }
        return ret;
    }
    async runSeparate(message, parsed, state, arg) {
        const index = arg.index == null ? state.phraseIndex : arg.index;
        const phrases = parsed.phrases.slice(index, index + arg.limit);
        if (!phrases.length) {
            const ret = await arg.process(message, "");
            if (arg.index != null) {
                ArgumentRunner.increaseIndex(parsed, state);
            }
            return ret;
        }
        const res = [];
        for (const phrase of phrases) {
            const response = await arg.process(message, phrase.value);
            if (Flag_js_1.Flag.is(response, Flag_js_1.FlagType.Cancel)) {
                return response;
            }
            res.push(response);
        }
        if (arg.index != null) {
            ArgumentRunner.increaseIndex(parsed, state);
        }
        return res;
    }
    runFlag(message, parsed, state, arg) {
        const names = Array.isArray(arg.flag) ? arg.flag : [arg.flag];
        if (arg.multipleFlags) {
            const amount = parsed.flags.filter(flag => names.some(name => name?.toLowerCase() === flag.key.toLowerCase())).length;
            return amount;
        }
        const flagFound = parsed.flags.some(flag => names.some(name => name?.toLowerCase() === flag.key.toLowerCase()));
        return arg.default == null ? flagFound : !flagFound;
    }
    async runOption(message, parsed, state, arg) {
        const names = Array.isArray(arg.flag) ? arg.flag : [arg.flag];
        if (arg.multipleFlags) {
            const values = parsed.optionFlags
                .filter(flag => names.some(name => name?.toLowerCase() === flag.key.toLowerCase()))
                .map(x => x.value)
                .slice(0, arg.limit);
            const res = [];
            for (const value of values) {
                res.push(await arg.process(message, value));
            }
            return res;
        }
        const foundFlag = parsed.optionFlags.find(flag => names.some(name => name?.toLowerCase() === flag.key.toLowerCase()));
        return arg.process(message, foundFlag != null ? foundFlag.value : "");
    }
    runText(message, parsed, state, arg) {
        const index = arg.index == null ? 0 : arg.index;
        const text = parsed.phrases
            .slice(index, index + arg.limit)
            .map(x => x.raw)
            .join("")
            .trim();
        return arg.process(message, text);
    }
    runContent(message, parsed, state, arg) {
        const index = arg.index == null ? 0 : arg.index;
        const content = parsed.all
            .slice(index, index + arg.limit)
            .map(x => x.raw)
            .join("")
            .trim();
        return arg.process(message, content);
    }
    async runRestContent(message, parsed, state, arg) {
        const index = arg.index == null ? state.index : arg.index;
        const rest = parsed.all
            .slice(index, index + arg.limit)
            .map(x => x.raw)
            .join("")
            .trim();
        const ret = await arg.process(message, rest);
        if (arg.index == null) {
            ArgumentRunner.increaseIndex(parsed, state);
        }
        return ret;
    }
    runNone(message, parsed, state, arg) {
        return arg.process(message, "");
    }
    static increaseIndex(parsed, state, n = 1) {
        state.phraseIndex += n;
        while (n > 0) {
            do {
                state.index++;
            } while (parsed.all[state.index] && parsed.all[state.index].type !== "Phrase");
            n--;
        }
    }
    static isShortCircuit(value) {
        return (Flag_js_1.Flag.is(value, Flag_js_1.FlagType.Cancel) ||
            Flag_js_1.Flag.is(value, Flag_js_1.FlagType.Timeout) ||
            Flag_js_1.Flag.is(value, Flag_js_1.FlagType.Retry) ||
            Flag_js_1.Flag.is(value, Flag_js_1.FlagType.Continue));
    }
    static fromArguments(args) {
        return function* generate() {
            const res = {};
            for (const [id, arg] of args) {
                res[id] = yield arg;
            }
            return res;
        };
    }
}
exports.ArgumentRunner = ArgumentRunner;
exports.ArgumentRunnerState = zod_1.z.object({
    index: zod_1.z.number(),
    phraseIndex: zod_1.z.number(),
    usedIndices: zod_1.z.set(zod_1.z.number())
});
//# sourceMappingURL=ArgumentRunner.js.map