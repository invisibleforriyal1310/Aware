"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ArgumentOptions = exports.ParsedValuePredicate = exports.DefaultValueSupplier = exports.DefaultArgumentOptions = exports.BaseArgumentOptions = exports.OtherwiseContentModifier = exports.ArgumentTypeCaster = exports.ArgumentType = exports.ArgumentMatch = exports.ArgumentPromptOptions = exports.PromptContentModifier = exports.OtherwiseContentSupplier = exports.FailureData = exports.ArgumentPromptResponse = exports.PromptContentSupplier = exports.ArgumentPromptData = exports.Argument = void 0;
const zod_1 = require("zod");
const Util_js_1 = require("../../../typings/Util.js");
const Constants_js_1 = require("../../../util/Constants.js");
const Util_js_2 = require("../../../util/Util.js");
const Flag_js_1 = require("../Flag.js");
class Argument {
    constructor(command, options = {}) {
        exports.ArgumentOptions.parse(options);
        const { match, type, flag, multipleFlags, index, unordered, limit, prompt, default: defaultValue, otherwise, modifyOtherwise } = options;
        this.command = command;
        this.match = match ?? Constants_js_1.ArgumentMatches.PHRASE;
        this.type = typeof type === "function" ? type.bind(this) : type ?? Constants_js_1.ArgumentTypes.STRING;
        this.flag = flag ?? null;
        this.multipleFlags = multipleFlags ?? false;
        this.index = index ?? null;
        this.unordered = unordered ?? false;
        this.limit = limit ?? Infinity;
        this.prompt = prompt ?? null;
        this.default = typeof defaultValue === "function" ? defaultValue.bind(this) : defaultValue ?? null;
        this.otherwise = typeof otherwise === "function" ? otherwise.bind(this) : otherwise ?? null;
        this.modifyOtherwise = modifyOtherwise ?? null;
    }
    get client() {
        return this.command.client;
    }
    get handler() {
        return this.command.handler;
    }
    cast(message, phrase) {
        return Argument.cast(this.type, this.handler.resolver, message, phrase);
    }
    async collect(message, commandInput = "", parsedInput = null) {
        const promptOptions = {
            ...this.handler.argumentDefaults.prompt,
            ...this.command.argumentDefaults.prompt,
            ...(typeof this.prompt === "object" ? this.prompt : {})
        };
        const isInfinite = promptOptions.infinite || (this.match === Constants_js_1.ArgumentMatches.SEPARATE && !commandInput);
        const additionalRetry = Number(Boolean(commandInput));
        const values = isInfinite ? [] : null;
        const getText = async (promptType, prompter, retryCount, inputMessage, inputPhrase, inputParsed) => {
            let text = await (0, Util_js_2.intoCallable)(prompter).call(this, message, {
                retries: retryCount,
                infinite: isInfinite,
                message: inputMessage,
                phrase: inputPhrase,
                failure: inputParsed
            });
            if (Array.isArray(text)) {
                text = text.join("\n");
            }
            const modifier = {
                start: promptOptions.modifyStart,
                retry: promptOptions.modifyRetry,
                timeout: promptOptions.modifyTimeout,
                ended: promptOptions.modifyEnded,
                cancel: promptOptions.modifyCancel
            }[promptType];
            if (modifier) {
                text = await modifier.call(this, message, text, {
                    retries: retryCount,
                    infinite: isInfinite,
                    message: inputMessage,
                    phrase: inputPhrase,
                    failure: inputParsed
                });
                if (Array.isArray(text)) {
                    text = text.join("\n");
                }
            }
            return text;
        };
        const promptOne = async (prevMessage, prevInput, prevParsed, retryCount) => {
            let sentStart;
            if (retryCount !== 1 || !isInfinite || !values?.length) {
                const promptType = retryCount === 1 ? "start" : "retry";
                const prompter = retryCount === 1 ? promptOptions.start : promptOptions.retry;
                const startText = await getText(promptType, prompter, retryCount, prevMessage, prevInput, prevParsed);
                if (startText) {
                    sentStart = await (message.util || message.channel).send(startText);
                    if (message.util && sentStart) {
                        message.util.setEditable(false);
                        message.util.setLastResponse(sentStart);
                        message.util.addMessage(sentStart);
                    }
                }
            }
            let input;
            try {
                input = (await message.channel.awaitMessages({
                    filter: m => m.author.id === message.author.id,
                    max: 1,
                    time: promptOptions.time,
                    errors: ["time"]
                })).first();
                if (message.util)
                    message.util.addMessage(input);
            }
            catch (err) {
                const timeoutText = await getText("timeout", promptOptions.timeout, retryCount, prevMessage, prevInput, "");
                if (timeoutText) {
                    const sentTimeout = await message.channel.send(timeoutText);
                    if (message.util)
                        message.util.addMessage(sentTimeout);
                }
                if (!promptOptions.time)
                    return Flag_js_1.Flag.cancel();
                return Flag_js_1.Flag.timeout(promptOptions.time);
            }
            if (promptOptions.breakout) {
                const looksLike = await this.handler.parseCommand(input);
                if (looksLike?.command)
                    return Flag_js_1.Flag.retry(input);
            }
            if (input?.content.toLowerCase() === promptOptions.cancelWord.toLowerCase()) {
                const cancelText = await getText("cancel", promptOptions.cancel, retryCount, input, input?.content, "cancel");
                if (cancelText) {
                    const sentCancel = await message.channel.send(cancelText);
                    if (message.util)
                        message.util.addMessage(sentCancel);
                }
                return Flag_js_1.Flag.cancel();
            }
            if (isInfinite && input?.content.toLowerCase() === promptOptions.stopWord.toLowerCase()) {
                if (!values.length)
                    return promptOne(input, input?.content, null, retryCount + 1);
                return values;
            }
            const parsedValue = await this.cast(input, input.content);
            if (Argument.isFailure(parsedValue)) {
                if (retryCount <= promptOptions.retries) {
                    return promptOne(input, input?.content, parsedValue, retryCount + 1);
                }
                const endedText = await getText("ended", promptOptions.ended, retryCount, input, input?.content, "stop");
                if (endedText) {
                    const sentEnded = await message.channel.send(endedText);
                    if (message.util)
                        message.util.addMessage(sentEnded);
                }
                return Flag_js_1.Flag.cancel();
            }
            if (isInfinite) {
                values.push(parsedValue);
                const limit = promptOptions.limit;
                if (values.length < limit)
                    return promptOne(message, input.content, parsedValue, 1);
                return values;
            }
            return parsedValue;
        };
        this.handler.addPrompt(message.channel, message.author);
        const returnValue = await promptOne(message, commandInput, parsedInput, 1 + additionalRetry);
        if (this.handler.commandUtil && message.util) {
            message.util.setEditable(false);
        }
        this.handler.removePrompt(message.channel, message.author);
        return returnValue;
    }
    async process(message, phrase) {
        const commandDefs = this.command.argumentDefaults;
        const handlerDefs = this.handler.argumentDefaults;
        const optional = (typeof this.prompt === "object" && this.prompt?.optional) ??
            commandDefs.prompt?.optional ??
            handlerDefs.prompt?.optional ??
            null;
        const doOtherwise = async (failure) => {
            const otherwise = this.otherwise ?? commandDefs.otherwise ?? handlerDefs.otherwise ?? null;
            const modifyOtherwise = this.modifyOtherwise ?? commandDefs.modifyOtherwise ?? handlerDefs.modifyOtherwise ?? null;
            let text = await (0, Util_js_2.intoCallable)(otherwise).call(this, message, {
                phrase,
                failure
            });
            if (Array.isArray(text)) {
                text = text.join("\n");
            }
            if (modifyOtherwise) {
                text = await modifyOtherwise.call(this, message, text, {
                    phrase,
                    failure: failure ?? null
                });
                if (Array.isArray(text)) {
                    text = text.join("\n");
                }
            }
            if (text) {
                const sent = await message.channel.send(text);
                if (message.util)
                    message.util.addMessage(sent);
            }
            return Flag_js_1.Flag.cancel();
        };
        if (!phrase && optional) {
            if (this.otherwise != null) {
                return doOtherwise(null);
            }
            return (0, Util_js_2.intoCallable)(this.default)(message, {
                phrase,
                failure: null
            });
        }
        const res = await this.cast(message, phrase);
        if (Argument.isFailure(res)) {
            if (this.otherwise != null) {
                return doOtherwise(res);
            }
            if (this.prompt != null) {
                return this.collect(message, phrase, res);
            }
            return this.default == null ? res : (0, Util_js_2.intoCallable)(this.default)(message, { phrase, failure: res });
        }
        return res;
    }
    static async cast(type, resolver, message, phrase) {
        if (Array.isArray(type)) {
            for (const entry of type) {
                if (Array.isArray(entry)) {
                    if (entry.some(t => t.toLowerCase() === phrase.toLowerCase())) {
                        return entry[0];
                    }
                }
                else if (entry.toLowerCase() === phrase.toLowerCase()) {
                    return entry;
                }
            }
            return null;
        }
        if (typeof type === "function") {
            let res = type(message, phrase);
            if ((0, Util_js_2.isPromise)(res))
                res = await res;
            return res;
        }
        if (type instanceof RegExp) {
            const match = phrase.match(type);
            if (!match)
                return null;
            const matches = [];
            if (type.global) {
                let matched;
                while ((matched = type.exec(phrase)) != null) {
                    matches.push(matched);
                }
            }
            return { match, matches };
        }
        if (resolver.type(type)) {
            let res = resolver.type(type)?.call(this, message, phrase);
            if ((0, Util_js_2.isPromise)(res))
                res = await res;
            return res;
        }
        return phrase || null;
    }
    static compose(...types) {
        return async function typeFn(message, phrase) {
            let acc = phrase;
            for (let entry of types) {
                if (typeof entry === "function")
                    entry = entry.bind(this);
                acc = await Argument.cast(entry, this.handler.resolver, message, acc);
                if (Argument.isFailure(acc))
                    return acc;
            }
            return acc;
        };
    }
    static composeWithFailure(...types) {
        return async function typeFn(message, phrase) {
            let acc = phrase;
            for (let entry of types) {
                if (typeof entry === "function")
                    entry = entry.bind(this);
                acc = await Argument.cast(entry, this.handler.resolver, message, acc);
            }
            return acc;
        };
    }
    static isFailure(value) {
        return value == null || Flag_js_1.Flag.is(value, Flag_js_1.FlagType.Fail);
    }
    static product(...types) {
        return async function typeFn(message, phrase) {
            const results = [];
            for (let entry of types) {
                if (typeof entry === "function")
                    entry = entry.bind(this);
                const res = await Argument.cast(entry, this.handler.resolver, message, phrase);
                if (Argument.isFailure(res))
                    return res;
                results.push(res);
            }
            return results;
        };
    }
    static range(type, min, max, inclusive = false) {
        return Argument.validate(type, (msg, p, x) => {
            const o = typeof x === "number" || typeof x === "bigint" ? x : x.length != null ? x.length : x.size != null ? x.size : x;
            return o >= min && (inclusive ? o <= max : o < max);
        });
    }
    static tagged(type, tag = type) {
        return async function typeFn(message, phrase) {
            if (typeof type === "function")
                type = type.bind(this);
            const res = await Argument.cast(type, this.handler.resolver, message, phrase);
            if (Argument.isFailure(res)) {
                return Flag_js_1.Flag.fail({ tag, value: res });
            }
            return { tag, value: res };
        };
    }
    static taggedUnion(...types) {
        return async function typeFn(message, phrase) {
            for (let entry of types) {
                entry = Argument.tagged(entry);
                const res = await Argument.cast(entry, this.handler.resolver, message, phrase);
                if (!Argument.isFailure(res))
                    return res;
            }
            return null;
        };
    }
    static taggedWithInput(type, tag = type) {
        return async function typeFn(message, phrase) {
            if (typeof type === "function")
                type = type.bind(this);
            const res = await Argument.cast(type, this.handler.resolver, message, phrase);
            if (Argument.isFailure(res)) {
                return Flag_js_1.Flag.fail({ tag, input: phrase, value: res });
            }
            return { tag, input: phrase, value: res };
        };
    }
    static union(...types) {
        return async function typeFn(message, phrase) {
            for (let entry of types) {
                if (typeof entry === "function")
                    entry = entry.bind(this);
                const res = await Argument.cast(entry, this.handler.resolver, message, phrase);
                if (!Argument.isFailure(res))
                    return res;
            }
            return null;
        };
    }
    static validate(type, predicate) {
        return async function typeFn(message, phrase) {
            if (typeof type === "function")
                type = type.bind(this);
            const res = await Argument.cast(type, this.handler.resolver, message, phrase);
            if (Argument.isFailure(res))
                return res;
            if (!predicate.call(this, message, phrase, res))
                return null;
            return res;
        };
    }
    static withInput(type) {
        return async function typeFn(message, phrase) {
            if (typeof type === "function")
                type = type.bind(this);
            const res = await Argument.cast(type, this.handler.resolver, message, phrase);
            if (Argument.isFailure(res)) {
                return Flag_js_1.Flag.fail({ input: phrase, value: res });
            }
            return { input: phrase, value: res };
        };
    }
}
exports.Argument = Argument;
exports.ArgumentPromptData = zod_1.z.object({
    retries: zod_1.z.number(),
    infinite: zod_1.z.boolean(),
    message: Util_js_1.MessageInstance,
    phrase: zod_1.z.string(),
    failure: zod_1.z.instanceof((Flag_js_1.Flag)).nullable()
});
exports.PromptContentSupplier = zod_1.z
    .function()
    .args(Util_js_1.MessageInstance, exports.ArgumentPromptData)
    .returns((0, Util_js_1.SyncOrAsync)(Util_js_1.MessageSendResolvable));
exports.ArgumentPromptResponse = zod_1.z.union([Util_js_1.MessageSendResolvable, exports.PromptContentSupplier]);
exports.FailureData = zod_1.z.object({
    phrase: zod_1.z.string(),
    failure: zod_1.z.instanceof((Flag_js_1.Flag)).nullable()
});
exports.OtherwiseContentSupplier = zod_1.z
    .function()
    .args(Util_js_1.MessageInstance, exports.FailureData)
    .returns((0, Util_js_1.SyncOrAsync)(Util_js_1.MessageSendResolvable));
exports.PromptContentModifier = zod_1.z
    .function()
    .args(Util_js_1.MessageInstance, zod_1.z.union([Util_js_1.MessageSendResolvable, exports.OtherwiseContentSupplier]))
    .returns((0, Util_js_1.SyncOrAsync)(Util_js_1.MessageSendResolvable));
exports.ArgumentPromptOptions = zod_1.z.object({
    breakout: zod_1.z.boolean().optional(),
    cancel: exports.ArgumentPromptResponse.optional(),
    cancelWord: zod_1.z.string().optional(),
    ended: exports.ArgumentPromptResponse.optional(),
    infinite: zod_1.z.boolean().optional(),
    limit: zod_1.z.number().optional(),
    modifyCancel: exports.PromptContentModifier.optional(),
    modifyEnded: exports.PromptContentModifier.optional(),
    modifyRetry: exports.PromptContentModifier.optional(),
    modifyStart: exports.PromptContentModifier.optional(),
    modifyTimeout: exports.PromptContentModifier.optional(),
    optional: zod_1.z.boolean().optional(),
    retries: zod_1.z.number().optional(),
    retry: exports.ArgumentPromptResponse.optional(),
    start: exports.ArgumentPromptResponse.optional(),
    stopWord: zod_1.z.string().optional(),
    time: zod_1.z.number().optional(),
    timeout: exports.ArgumentPromptResponse.optional()
});
exports.ArgumentMatch = zod_1.z.enum(["phrase", "flag", "option", "rest", "separate", "text", "content", "restContent", "none"]);
exports.ArgumentType = zod_1.z.union([zod_1.z.string(), zod_1.z.union([zod_1.z.string(), zod_1.z.string().array()]).array(), zod_1.z.instanceof(RegExp)]);
exports.ArgumentTypeCaster = zod_1.z.function().args(Util_js_1.MessageInstance, zod_1.z.string()).returns(zod_1.z.any());
exports.OtherwiseContentModifier = zod_1.z
    .function()
    .args(Util_js_1.MessageInstance, zod_1.z.union([Util_js_1.MessageSendResolvable, exports.OtherwiseContentSupplier], exports.FailureData))
    .returns((0, Util_js_1.SyncOrAsync)(Util_js_1.MessageSendResolvable));
exports.BaseArgumentOptions = zod_1.z.object({
    otherwise: zod_1.z.union([Util_js_1.MessageSendResolvable, exports.OtherwiseContentSupplier]).optional(),
    modifyOtherwise: exports.OtherwiseContentModifier.optional()
});
exports.DefaultArgumentOptions = exports.BaseArgumentOptions.extend({
    prompt: exports.ArgumentPromptOptions.optional()
});
exports.DefaultValueSupplier = zod_1.z.function().args(Util_js_1.MessageInstance, exports.FailureData).returns(zod_1.z.any());
exports.ParsedValuePredicate = zod_1.z.function().args(Util_js_1.MessageInstance, zod_1.z.string(), zod_1.z.any()).returns(zod_1.z.boolean());
exports.ArgumentOptions = zod_1.z.object({
    default: zod_1.z.any(),
    description: zod_1.z.any(),
    flag: zod_1.z.union([zod_1.z.string(), zod_1.z.string().array()]).nullish(),
    id: zod_1.z.string().nullish(),
    index: zod_1.z.number().nullish(),
    limit: zod_1.z.number().optional(),
    match: zod_1.z.nativeEnum(Constants_js_1.ArgumentMatches).optional(),
    modifyOtherwise: exports.OtherwiseContentModifier.nullish().optional(),
    multipleFlags: zod_1.z.boolean().optional(),
    otherwise: zod_1.z.union([Util_js_1.MessageSendResolvable, exports.OtherwiseContentSupplier]).nullish(),
    prompt: zod_1.z.union([exports.ArgumentPromptOptions, zod_1.z.boolean()]).nullish(),
    type: zod_1.z.union([exports.ArgumentType, exports.ArgumentTypeCaster]).optional(),
    unordered: zod_1.z.union([zod_1.z.boolean(), zod_1.z.number(), zod_1.z.number().array()]).optional()
});
//# sourceMappingURL=Argument.js.map