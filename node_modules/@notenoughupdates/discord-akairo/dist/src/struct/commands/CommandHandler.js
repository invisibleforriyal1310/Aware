"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SlashResolveType = exports.CommandHandlerOptions = exports.PrefixSupplier = exports.IgnoreCheckPredicate = exports.MentionPrefixPredicate = exports.RegisterInteractionCommandError = exports.CommandHandler = void 0;
const discord_js_1 = require("discord.js");
const zod_1 = require("zod");
const Util_js_1 = require("../../typings/Util.js");
const AkairoError_js_1 = require("../../util/AkairoError.js");
const AkairoMessage_js_1 = require("../../util/AkairoMessage.js");
const Constants_js_1 = require("../../util/Constants.js");
const Util_js_2 = require("../../util/Util.js");
const AkairoClient_js_1 = require("../AkairoClient.js");
const AkairoHandler_js_1 = require("../AkairoHandler.js");
const ContextMenuCommandHandler_js_1 = require("../contextMenuCommands/ContextMenuCommandHandler.js");
const Argument_js_1 = require("./arguments/Argument.js");
const TypeResolver_js_1 = require("./arguments/TypeResolver.js");
const Command_js_1 = require("./Command.js");
const CommandUtil_js_1 = require("./CommandUtil.js");
const Flag_js_1 = require("./Flag.js");
class CommandHandler extends AkairoHandler_js_1.AkairoHandler {
    constructor(client, options) {
        zod_1.z.instanceof(AkairoClient_js_1.AkairoClient).parse(client);
        exports.CommandHandlerOptions.parse(options);
        const { directory, classToHandle = Command_js_1.Command, extensions = [".js", ".ts"], automateCategories, loadFilter, blockClient = true, blockBots = true, fetchMembers = false, handleEdits = false, storeMessages = false, commandUtil = false, commandUtilLifetime = 3e5, commandUtilSweepInterval = 3e5, defaultCooldown = 0, ignoreCooldown = client.ownerID, ignorePermissions = [], argumentDefaults = {}, prefix = "!", allowMention = true, aliasReplacement, autoDefer = false, typing = false, autoRegisterSlashCommands = false, execSlash = false, skipBuiltInPostInhibitors = false } = options;
        if (!(classToHandle.prototype instanceof Command_js_1.Command || classToHandle === Command_js_1.Command)) {
            throw new AkairoError_js_1.AkairoError("INVALID_CLASS_TO_HANDLE", classToHandle.name, Command_js_1.Command.name);
        }
        super(client, {
            directory,
            classToHandle,
            extensions,
            automateCategories,
            loadFilter
        });
        this.autoRegisterSlashCommands = autoRegisterSlashCommands;
        this.typing = typing;
        this.autoDefer = autoDefer;
        this.resolver = new TypeResolver_js_1.TypeResolver(this);
        this.aliases = new discord_js_1.Collection();
        this.aliasReplacement = aliasReplacement;
        this.prefixes = new discord_js_1.Collection();
        this.blockClient = blockClient;
        this.blockBots = blockBots;
        this.fetchMembers = fetchMembers;
        this.handleEdits = handleEdits;
        this.storeMessages = storeMessages;
        this.commandUtil = commandUtil;
        if ((this.handleEdits || this.storeMessages) && !this.commandUtil)
            throw new AkairoError_js_1.AkairoError("COMMAND_UTIL_EXPLICIT");
        this.commandUtilLifetime = commandUtilLifetime;
        this.commandUtilSweepInterval = commandUtilSweepInterval;
        if (this.commandUtilSweepInterval > 0)
            setInterval(() => this.sweepCommandUtil(), this.commandUtilSweepInterval).unref();
        this.commandUtils = new discord_js_1.Collection();
        this.cooldowns = new discord_js_1.Collection();
        this.defaultCooldown = defaultCooldown;
        this.ignoreCooldown = typeof ignoreCooldown === "function" ? ignoreCooldown.bind(this) : ignoreCooldown;
        this.ignorePermissions = typeof ignorePermissions === "function" ? ignorePermissions.bind(this) : ignorePermissions;
        this.prompts = new discord_js_1.Collection();
        this.argumentDefaults = (0, Util_js_2.deepAssign)({
            prompt: {
                start: "",
                retry: "",
                timeout: "",
                ended: "",
                cancel: "",
                retries: 1,
                time: 30000,
                cancelWord: "cancel",
                stopWord: "stop",
                optional: false,
                infinite: false,
                limit: Infinity,
                breakout: true
            }
        }, argumentDefaults);
        this.prefix = typeof prefix === "function" ? prefix.bind(this) : prefix;
        this.allowMention = typeof allowMention === "function" ? allowMention.bind(this) : allowMention;
        this.inhibitorHandler = null;
        this.autoDefer = autoDefer;
        this.execSlash = execSlash;
        this.skipBuiltInPostInhibitors = skipBuiltInPostInhibitors;
        this.setup();
    }
    setup() {
        this.client.once("ready", () => {
            if (this.autoRegisterSlashCommands)
                this.registerInteractionCommands();
            this.client.on("messageCreate", async (m) => {
                const message = m.partial ? await m.fetch().catch(() => null) : m;
                if (!message)
                    return;
                this.handle(m);
            });
            if (this.handleEdits) {
                this.client.on("messageUpdate", async (o, m) => {
                    const message = m.partial ? await m.fetch().catch(() => null) : m;
                    if (!message)
                        return;
                    const original = o.partial ? await o.fetch().catch(() => null) : o;
                    if (!original)
                        return;
                    if (original.content === message.content)
                        return;
                    if (this.handleEdits)
                        this.handle(message);
                });
            }
            this.client.on("interactionCreate", i => {
                if (i.isChatInputCommand())
                    this.handleSlash(i);
                if (i.type === discord_js_1.InteractionType.ApplicationCommandAutocomplete)
                    this.handleAutocomplete(i);
            });
        });
        if (this.commandUtil) {
            this.client.on("messageDelete", message => {
                if (message.inGuild()) {
                    CommandUtil_js_1.CommandUtil.deletedMessages.add(message.id);
                }
            });
        }
    }
    async registerInteractionCommands() {
        this.client.emit("akairoDebug", `[registerInteractionCommands] Started registering interaction commands...`);
        const parsedSlashCommands = [];
        const guildSlashCommandsParsed = new discord_js_1.Collection();
        const parseDescriptionCommand = (description) => {
            if (typeof description === "object") {
                if (typeof description.content === "function")
                    return description.content();
                if (typeof description.content === "string")
                    return description.content;
            }
            return description;
        };
        for (const [, data] of this.modules) {
            if (!data.slash)
                continue;
            const obj = {
                name: data.aliases[0]?.toLocaleLowerCase() || data.id?.toLocaleLowerCase(),
                description: parseDescriptionCommand(data.description) || "No description provided.",
                options: data.slashOptions?.map(o => {
                    const temp = { ...o, resolve: undefined };
                    return temp;
                }),
                guilds: data.slashGuilds ?? [],
                dmPermission: data.slashDmPermission,
                type: discord_js_1.ApplicationCommandType.ChatInput,
                nameLocalizations: data.localization.nameLocalizations,
                descriptionLocalizations: data.localization.descriptionLocalizations
            };
            if ("slashDefaultMemberPermissions" in data)
                obj.defaultMemberPermissions = data.slashDefaultMemberPermissions;
            parsedSlashCommands.push(obj);
        }
        const contextCommandHandler = Object.values(this.client).find(v => v instanceof ContextMenuCommandHandler_js_1.ContextMenuCommandHandler);
        if (contextCommandHandler) {
            for (const [, data] of contextCommandHandler.modules) {
                const obj = {
                    name: data.name,
                    guilds: data.guilds ?? [],
                    dmPermission: data.dmPermission,
                    type: data.type,
                    nameLocalizations: data.nameLocalizations
                };
                if ("defaultMemberPermissions" in data)
                    obj.defaultMemberPermissions = data.defaultMemberPermissions;
                parsedSlashCommands.push(obj);
            }
        }
        const slashCommandsApp = parsedSlashCommands
            .filter(({ guilds }) => guilds.length === 0)
            .map(this.mapInteraction)
            .sort(this.sortInteraction);
        const currentGlobalCommands = (await this.client.application?.commands.fetch())
            .map(this.mapInteraction)
            .sort(this.sortInteraction);
        if (!(0, Util_js_2.deepEquals)(currentGlobalCommands, slashCommandsApp)) {
            this.client.emit("akairoDebug", "[registerInteractionCommands] Updating global interaction commands.", slashCommandsApp);
            await this.client.application?.commands.set(slashCommandsApp).catch(error => {
                if (error instanceof discord_js_1.DiscordAPIError)
                    throw new RegisterInteractionCommandError(error, "global", slashCommandsApp);
                else
                    throw error;
            });
        }
        else {
            this.client.emit("akairoDebug", "[registerInteractionCommands] Global interaction commands are up to date.");
        }
        for (const options of parsedSlashCommands) {
            for (const guildId of options.guilds) {
                guildSlashCommandsParsed.set(guildId, [...(guildSlashCommandsParsed.get(guildId) ?? []), this.mapInteraction(options)]);
            }
        }
        if (guildSlashCommandsParsed.size) {
            guildSlashCommandsParsed.each(async (value, key) => {
                const guild = this.client.guilds.cache.get(key);
                if (!guild)
                    return;
                const sortedCommands = value.sort(this.sortInteraction);
                const currentGuildCommands = (await guild.commands.fetch()).map(this.mapInteraction).sort(this.sortInteraction);
                if (!(0, Util_js_2.deepEquals)(currentGuildCommands, sortedCommands)) {
                    this.client.emit("akairoDebug", `[registerInteractionCommands] Updating guild commands for ${guild.name}.`, sortedCommands);
                    await guild.commands.set(sortedCommands).catch(error => {
                        if (error instanceof discord_js_1.DiscordAPIError)
                            throw new RegisterInteractionCommandError(error, "guild", sortedCommands, guild);
                        else
                            throw error;
                    });
                }
                else {
                    this.client.emit("akairoDebug", `[registerInteractionCommands] No changes needed for ${guild.name}.`);
                }
            });
        }
    }
    mapInteraction(interaction) {
        return {
            name: interaction.name,
            description: interaction.type === discord_js_1.ApplicationCommandType.ChatInput ? interaction.description ?? "" : undefined,
            options: interaction.type === discord_js_1.ApplicationCommandType.ChatInput
                ?
                    interaction.options ?? []
                : undefined,
            defaultMemberPermissions: interaction.defaultMemberPermissions,
            dmPermission: interaction.dmPermission,
            type: interaction.type,
            nameLocalizations: interaction.nameLocalizations,
            descriptionLocalizations: interaction.type === discord_js_1.ApplicationCommandType.ChatInput ? interaction.descriptionLocalizations : undefined
        };
    }
    sortInteraction(a, b) {
        if (a.name < b.name)
            return -1;
        if (a.name > b.name)
            return 1;
        return 0;
    }
    register(command, filepath) {
        super.register(command, filepath);
        for (let alias of command.aliases) {
            const conflict = this.aliases.get(alias.toLowerCase());
            if (conflict)
                throw new AkairoError_js_1.AkairoError("ALIAS_CONFLICT", alias, command.id, conflict);
            alias = alias.toLowerCase();
            this.aliases.set(alias, command.id);
            if (this.aliasReplacement) {
                const replacement = alias.replace(this.aliasReplacement, "");
                if (replacement !== alias) {
                    const replacementConflict = this.aliases.get(replacement);
                    if (replacementConflict)
                        throw new AkairoError_js_1.AkairoError("ALIAS_CONFLICT", replacement, command.id, replacementConflict);
                    this.aliases.set(replacement, command.id);
                }
            }
        }
        if (command.prefix != null) {
            let newEntry = false;
            if (Array.isArray(command.prefix)) {
                for (const prefix of command.prefix) {
                    const prefixes = this.prefixes.get(prefix);
                    if (prefixes) {
                        prefixes.add(command.id);
                    }
                    else {
                        this.prefixes.set(prefix, new Set([command.id]));
                        newEntry = true;
                    }
                }
            }
            else {
                const prefixes = this.prefixes.get(command.prefix);
                if (prefixes) {
                    prefixes.add(command.id);
                }
                else {
                    this.prefixes.set(command.prefix, new Set([command.id]));
                    newEntry = true;
                }
            }
            if (newEntry) {
                this.prefixes = this.prefixes.sort((aVal, bVal, aKey, bKey) => (0, Util_js_2.prefixCompare)(aKey, bKey));
            }
        }
    }
    deregister(command) {
        for (let alias of command.aliases) {
            alias = alias.toLowerCase();
            this.aliases.delete(alias);
            if (this.aliasReplacement) {
                const replacement = alias.replace(this.aliasReplacement, "");
                if (replacement !== alias)
                    this.aliases.delete(replacement);
            }
        }
        if (command.prefix != null) {
            if (Array.isArray(command.prefix)) {
                for (const prefix of command.prefix) {
                    const prefixes = this.prefixes.get(prefix);
                    if (prefixes?.size === 1) {
                        this.prefixes.delete(prefix);
                    }
                    else {
                        prefixes?.delete(prefix);
                    }
                }
            }
            else {
                const prefixes = this.prefixes.get(command.prefix);
                if (prefixes?.size === 1) {
                    this.prefixes.delete(command.prefix);
                }
                else {
                    prefixes?.delete(command.prefix);
                }
            }
        }
        super.deregister(command);
    }
    async handle(message) {
        try {
            if (this.fetchMembers && message.guild && !message.member && !message.webhookId) {
                await message.guild.members.fetch(message.author);
            }
            if (await this.runAllTypeInhibitors(message)) {
                return false;
            }
            if (this.commandUtil) {
                if (this.commandUtils.has(message.id)) {
                    message.util = this.commandUtils.get(message.id);
                }
                else {
                    message.util = new CommandUtil_js_1.CommandUtil(this, message);
                    this.commandUtils.set(message.id, message.util);
                }
            }
            if (await this.runPreTypeInhibitors(message)) {
                return false;
            }
            let parsed = await this.parseCommand(message);
            if (!parsed.command) {
                const overParsed = await this.parseCommandOverwrittenPrefixes(message);
                if (overParsed.command || (parsed.prefix == null && overParsed.prefix != null)) {
                    parsed = overParsed;
                }
            }
            if (this.commandUtil) {
                message.util.parsed = parsed;
            }
            if (parsed.command?.slashOnly) {
                this.emit(Constants_js_1.CommandHandlerEvents.SLASH_ONLY, message, parsed.command);
                return false;
            }
            let ran;
            if (!parsed.command) {
                ran = await this.handleRegexAndConditionalCommands(message);
            }
            else {
                ran = await this.handleDirectCommand(message, parsed.content, parsed.command);
            }
            if (ran === false) {
                this.emit(Constants_js_1.CommandHandlerEvents.MESSAGE_INVALID, message);
                return false;
            }
            return ran;
        }
        catch (err) {
            this.emitError(err, message);
            return null;
        }
    }
    async handleSlash(interaction) {
        const commandModule = this.findCommand(interaction.commandName);
        if (!commandModule) {
            this.emit(Constants_js_1.CommandHandlerEvents.SLASH_NOT_FOUND, interaction);
            return false;
        }
        const message = new AkairoMessage_js_1.AkairoMessage(this.client, interaction);
        try {
            if (this.fetchMembers && message.guild && !message.member) {
                await message.guild.members.fetch(message.author);
            }
            if (await this.runAllTypeInhibitors(message, true)) {
                return false;
            }
            if (this.commandUtil) {
                if (this.commandUtils.has(message.id)) {
                    message.util = this.commandUtils.get(message.id);
                }
                else {
                    message.util = new CommandUtil_js_1.CommandUtil(this, message);
                    this.commandUtils.set(message.id, message.util);
                }
            }
            if (await this.runPreTypeInhibitors(message)) {
                return false;
            }
            let parsed = await this.parseCommand(message);
            if (!parsed.command) {
                const overParsed = await this.parseCommandOverwrittenPrefixes(message);
                if (overParsed.command || (parsed.prefix == null && overParsed.prefix != null)) {
                    parsed = overParsed;
                }
            }
            if (this.commandUtil) {
                message.util.parsed = parsed;
            }
            if (await this.runPostTypeInhibitors(message, commandModule)) {
                return false;
            }
            const convertedOptions = {};
            if (interaction.options["_group"])
                convertedOptions["subcommandGroup"] = interaction.options["_group"];
            if (interaction.options["_subcommand"])
                convertedOptions["subcommand"] = interaction.options["_subcommand"];
            for (const option of interaction.options["_hoistedOptions"]) {
                if (option.type === discord_js_1.ApplicationCommandOptionType.Subcommand ||
                    option.type === discord_js_1.ApplicationCommandOptionType.SubcommandGroup)
                    continue;
                const originalOption = commandModule.slashOptions?.find(o => o.name === option.name);
                const func = `get${originalOption && "resolve" in originalOption && originalOption.resolve
                    ? originalOption.resolve
                    : discord_js_1.ApplicationCommandOptionType[option.type]}`;
                convertedOptions[option.name] =
                    func === "getMember"
                        ? interaction.options.getMember(option.name)
                        : func === "getChannel"
                            ? interaction.options.getChannel(option.name, false)
                            : interaction.options[func](option.name, false);
            }
            out: {
                if (convertedOptions.subcommand || convertedOptions.subcommandGroup) {
                    const usedSubcommandOrGroup = commandModule.slashOptions?.find(o => o.name === convertedOptions.subcommand);
                    if (!usedSubcommandOrGroup) {
                        this.client.emit("akairoDebug", "[handleSlash] Unable to find subcommand");
                        break out;
                    }
                    if (usedSubcommandOrGroup.type === discord_js_1.ApplicationCommandOptionType.Subcommand) {
                        if (!usedSubcommandOrGroup.options) {
                            this.client.emit("akairoDebug", "[handleSlash] Unable to find subcommand options");
                            break out;
                        }
                        handleOptions(usedSubcommandOrGroup.options);
                    }
                    else if (usedSubcommandOrGroup.type === discord_js_1.ApplicationCommandOptionType.SubcommandGroup) {
                        const usedSubCommand = usedSubcommandOrGroup.options?.find(subcommand => subcommand.name === convertedOptions.subcommand);
                        if (!usedSubCommand) {
                            this.client.emit("akairoDebug", "[handleSlash] Unable to find subcommand");
                            break out;
                        }
                        else if (!usedSubCommand.options) {
                            this.client.emit("akairoDebug", "[handleSlash] Unable to find subcommand options");
                            break out;
                        }
                        handleOptions(usedSubCommand.options);
                    }
                    else {
                        throw new AkairoError_js_1.AkairoError("UNEXPECTED_SLASH_COMMAND_TYPE", usedSubcommandOrGroup.type);
                    }
                }
                else {
                    handleOptions((commandModule.slashOptions ?? []));
                }
                function handleOptions(options) {
                    for (const option of options) {
                        switch (option.type) {
                            case discord_js_1.ApplicationCommandOptionType.Boolean:
                                convertedOptions[option.name] ??= false;
                                break;
                            case discord_js_1.ApplicationCommandOptionType.Channel:
                            case discord_js_1.ApplicationCommandOptionType.Integer:
                            case discord_js_1.ApplicationCommandOptionType.Mentionable:
                            case discord_js_1.ApplicationCommandOptionType.Number:
                            case discord_js_1.ApplicationCommandOptionType.Role:
                            case discord_js_1.ApplicationCommandOptionType.String:
                            case discord_js_1.ApplicationCommandOptionType.User:
                            case discord_js_1.ApplicationCommandOptionType.Attachment:
                                convertedOptions[option.name] ??= null;
                                break;
                            default: {
                                const exhaustiveCheck = option;
                                convertedOptions[option.name] ??= null;
                                break;
                            }
                        }
                    }
                }
            }
            let key;
            try {
                if (commandModule.lock)
                    key = commandModule.lock(message, convertedOptions);
                if ((0, Util_js_2.isPromise)(key))
                    key = await key;
                if (key) {
                    if (commandModule.locker?.has(key)) {
                        key = null;
                        this.emit(Constants_js_1.CommandHandlerEvents.COMMAND_LOCKED, message, commandModule);
                        return true;
                    }
                    commandModule.locker?.add(key);
                }
            }
            catch (err) {
                this.emitError(err, message, commandModule);
            }
            finally {
                if (key)
                    commandModule.locker?.delete(key);
            }
            if (this.autoDefer || commandModule.slashEphemeral) {
                await message.interaction.deferReply({ ephemeral: commandModule.slashEphemeral });
            }
            try {
                this.emit(Constants_js_1.CommandHandlerEvents.SLASH_STARTED, message, commandModule, convertedOptions);
                const ret = Object.getOwnPropertyNames(Object.getPrototypeOf(commandModule)).includes("execSlash") || this.execSlash
                    ? await commandModule.execSlash(message, convertedOptions)
                    : await commandModule.exec(message, convertedOptions);
                this.emit(Constants_js_1.CommandHandlerEvents.SLASH_FINISHED, message, commandModule, convertedOptions, ret);
                return true;
            }
            catch (err) {
                this.emit(Constants_js_1.CommandHandlerEvents.SLASH_ERROR, err, message, commandModule);
                return false;
            }
        }
        catch (err) {
            this.emitError(err, message, commandModule);
            return null;
        }
    }
    handleAutocomplete(interaction) {
        const commandModule = this.findCommand(interaction.commandName);
        if (!commandModule) {
            this.emit(Constants_js_1.CommandHandlerEvents.SLASH_NOT_FOUND, interaction);
            return;
        }
        this.client.emit("akairoDebug", `[handleAutocomplete] Autocomplete started for ${interaction.commandName}`);
        commandModule.autocomplete(interaction);
    }
    async handleDirectCommand(message, content, command, ignore = false) {
        let key;
        try {
            if (!ignore) {
                if (message.editedTimestamp && !command.editable)
                    return false;
                if (await this.runPostTypeInhibitors(message, command))
                    return false;
            }
            const before = command.before(message);
            if ((0, Util_js_2.isPromise)(before))
                await before;
            const args = await command.parse(message, content);
            if (Flag_js_1.Flag.is(args, Flag_js_1.FlagType.Cancel)) {
                this.emit(Constants_js_1.CommandHandlerEvents.COMMAND_CANCELLED, message, command);
                return true;
            }
            else if (Flag_js_1.Flag.is(args, Flag_js_1.FlagType.Timeout)) {
                this.emit(Constants_js_1.CommandHandlerEvents.COMMAND_TIMEOUT, message, command, args.time);
                return true;
            }
            else if (Flag_js_1.Flag.is(args, Flag_js_1.FlagType.Retry)) {
                this.emit(Constants_js_1.CommandHandlerEvents.COMMAND_BREAKOUT, message, command, args.message);
                return this.handle(args.message);
            }
            else if (Flag_js_1.Flag.is(args, Flag_js_1.FlagType.Continue)) {
                const continueCommand = this.modules.get(args.command);
                return this.handleDirectCommand(message, args.rest, continueCommand, args.ignore);
            }
            if (!ignore) {
                if (command.lock)
                    key = command.lock(message, args);
                if ((0, Util_js_2.isPromise)(key))
                    key = await key;
                if (key) {
                    if (command.locker?.has(key)) {
                        key = null;
                        this.emit(Constants_js_1.CommandHandlerEvents.COMMAND_LOCKED, message, command);
                        return true;
                    }
                    command.locker?.add(key);
                }
            }
            await this.runCommand(message, command, args);
            return true;
        }
        catch (err) {
            this.emitError(err, message, command);
            return null;
        }
        finally {
            if (key)
                command.locker?.delete(key);
        }
    }
    async handleRegexAndConditionalCommands(message) {
        const ran1 = await this.handleRegexCommands(message);
        const ran2 = await this.handleConditionalCommands(message);
        return ran1 || ran2;
    }
    async handleRegexCommands(message) {
        const hasRegexCommands = [];
        for (const command of this.modules.values()) {
            if (message.editedTimestamp ? command.editable : true) {
                const regex = typeof command.regex === "function" ? command.regex(message) : command.regex;
                if (regex)
                    hasRegexCommands.push({ command, regex });
            }
        }
        const matchedCommands = [];
        for (const entry of hasRegexCommands) {
            const match = message.content.match(entry.regex);
            if (!match)
                continue;
            const matches = [];
            if (entry.regex.global) {
                let matched;
                while ((matched = entry.regex.exec(message.content)) != null) {
                    matches.push(matched);
                }
            }
            matchedCommands.push({ command: entry.command, match, matches });
        }
        if (!matchedCommands.length) {
            return false;
        }
        const promises = [];
        for (const { command, match, matches } of matchedCommands) {
            promises.push((async () => {
                try {
                    if (await this.runPostTypeInhibitors(message, command))
                        return;
                    const before = command.before(message);
                    if ((0, Util_js_2.isPromise)(before))
                        await before;
                    await this.runCommand(message, command, { match, matches });
                }
                catch (err) {
                    this.emitError(err, message, command);
                }
            })());
        }
        await Promise.all(promises);
        return true;
    }
    async handleConditionalCommands(message) {
        const trueCommands = [];
        const filterPromises = [];
        for (const command of this.modules.values()) {
            if (message.editedTimestamp && !command.editable)
                continue;
            filterPromises.push((async () => {
                let cond = command.condition(message);
                if ((0, Util_js_2.isPromise)(cond))
                    cond = await cond;
                if (cond)
                    trueCommands.push(command);
            })());
        }
        await Promise.all(filterPromises);
        if (!trueCommands.length) {
            return false;
        }
        const promises = [];
        for (const command of trueCommands) {
            promises.push((async () => {
                try {
                    if (await this.runPostTypeInhibitors(message, command))
                        return;
                    const before = command.before(message);
                    if ((0, Util_js_2.isPromise)(before))
                        await before;
                    await this.runCommand(message, command, {});
                }
                catch (err) {
                    this.emitError(err, message, command);
                }
            })());
        }
        await Promise.all(promises);
        return true;
    }
    async runAllTypeInhibitors(message, slash = false) {
        const reason = this.inhibitorHandler ? await this.inhibitorHandler.test("all", message) : null;
        if (reason != null) {
            this.emit(Constants_js_1.CommandHandlerEvents.MESSAGE_BLOCKED, message, reason);
        }
        else if (!message.author) {
            this.emit(Constants_js_1.CommandHandlerEvents.MESSAGE_BLOCKED, message, Constants_js_1.BuiltInReasons.AUTHOR_NOT_FOUND);
        }
        else if (this.blockClient && message.author.id === this.client.user?.id) {
            this.emit(Constants_js_1.CommandHandlerEvents.MESSAGE_BLOCKED, message, Constants_js_1.BuiltInReasons.CLIENT);
        }
        else if (this.blockBots && message.author.bot) {
            this.emit(Constants_js_1.CommandHandlerEvents.MESSAGE_BLOCKED, message, Constants_js_1.BuiltInReasons.BOT);
        }
        else if (!slash && this.hasPrompt(message.channel, message.author)) {
            this.emit(Constants_js_1.CommandHandlerEvents.IN_PROMPT, message);
        }
        else {
            return false;
        }
        return true;
    }
    async runPreTypeInhibitors(message) {
        const reason = this.inhibitorHandler ? await this.inhibitorHandler.test("pre", message) : null;
        if (reason != null) {
            this.emit(Constants_js_1.CommandHandlerEvents.MESSAGE_BLOCKED, message, reason);
        }
        else {
            return false;
        }
        return true;
    }
    async runPostTypeInhibitors(message, command, slash = false) {
        const event = slash ? Constants_js_1.CommandHandlerEvents.SLASH_BLOCKED : Constants_js_1.CommandHandlerEvents.COMMAND_BLOCKED;
        if (!this.skipBuiltInPostInhibitors) {
            if (command.ownerOnly) {
                const isOwner = this.client.isOwner(message.author);
                if (!isOwner) {
                    this.emit(event, message, command, Constants_js_1.BuiltInReasons.OWNER);
                    return true;
                }
            }
            if (command.superUserOnly) {
                const isSuperUser = this.client.isSuperUser(message.author);
                if (!isSuperUser) {
                    this.emit(event, message, command, Constants_js_1.BuiltInReasons.SUPER_USER);
                    return true;
                }
            }
            if (command.channel === "guild" && !message.inGuild()) {
                this.emit(event, message, command, Constants_js_1.BuiltInReasons.GUILD);
                return true;
            }
            if (command.channel === "dm" && message.inGuild()) {
                this.emit(event, message, command, Constants_js_1.BuiltInReasons.DM);
                return true;
            }
            if (command.onlyNsfw && !("nsfw" in (message.channel ?? {}))) {
                this.emit(event, message, command, Constants_js_1.BuiltInReasons.NOT_NSFW);
                return true;
            }
        }
        if (!this.skipBuiltInPostInhibitors) {
            if (await this.runPermissionChecks(message, command, slash)) {
                return true;
            }
        }
        const reason = this.inhibitorHandler ? await this.inhibitorHandler.test("post", message, command) : null;
        if (this.skipBuiltInPostInhibitors && reason == null) {
            if (await this.runPermissionChecks(message, command, slash)) {
                return true;
            }
        }
        if (reason != null) {
            this.emit(event, message, command, reason);
            return true;
        }
        if (this.runCooldowns(message, command)) {
            return true;
        }
        return false;
    }
    async runPermissionChecks(message, command, slash = false) {
        const event = slash ? Constants_js_1.CommandHandlerEvents.SLASH_MISSING_PERMISSIONS : Constants_js_1.CommandHandlerEvents.MISSING_PERMISSIONS;
        if (command.clientPermissions) {
            if (typeof command.clientPermissions === "function") {
                let missing = command.clientPermissions(message);
                if ((0, Util_js_2.isPromise)(missing))
                    missing = await missing;
                if (missing != null) {
                    this.emit(event, message, command, "client", missing);
                    return true;
                }
            }
            else if (message.inGuild()) {
                if (!message.channel || message.channel.isDMBased())
                    return false;
                const missing = message.channel?.permissionsFor(message.guild.members.me)?.missing(command.clientPermissions);
                if (missing?.length) {
                    this.emit(event, message, command, "client", missing);
                    return true;
                }
            }
        }
        if (command.userPermissions) {
            const ignorer = command.ignorePermissions || this.ignorePermissions;
            const isIgnored = Array.isArray(ignorer)
                ? ignorer.includes(message.author.id)
                : typeof ignorer === "function"
                    ? ignorer(message, command)
                    : message.author.id === ignorer;
            if (!isIgnored) {
                if (typeof command.userPermissions === "function") {
                    let missing = command.userPermissions(message);
                    if ((0, Util_js_2.isPromise)(missing))
                        missing = await missing;
                    if (missing != null) {
                        this.emit(event, message, command, "user", missing);
                        return true;
                    }
                }
                else if (message.inGuild()) {
                    if (!message.channel || message.channel.isDMBased())
                        return false;
                    const missing = message.channel?.permissionsFor(message.author)?.missing(command.userPermissions);
                    if (missing?.length) {
                        this.emit(event, message, command, "user", missing);
                        return true;
                    }
                }
            }
        }
        return false;
    }
    runCooldowns(message, command) {
        const id = message.author?.id;
        const ignorer = command.ignoreCooldown || this.ignoreCooldown;
        const isIgnored = Array.isArray(ignorer)
            ? ignorer.includes(id)
            : typeof ignorer === "function"
                ?
                    ignorer(message, command)
                : id === ignorer;
        if (isIgnored)
            return false;
        const time = command.cooldown != null ? command.cooldown : this.defaultCooldown;
        if (!time)
            return false;
        const endTime = message.createdTimestamp + time;
        if (!this.cooldowns.has(id))
            this.cooldowns.set(id, {});
        if (!this.cooldowns.get(id)[command.id]) {
            this.cooldowns.get(id)[command.id] = {
                timer: setTimeout(() => {
                    if (this.cooldowns.get(id)[command.id]) {
                        clearTimeout(this.cooldowns.get(id)[command.id].timer);
                    }
                    this.cooldowns.get(id)[command.id] = null;
                    if (!Object.keys(this.cooldowns.get(id)).length) {
                        this.cooldowns.delete(id);
                    }
                }, time).unref(),
                end: endTime,
                uses: 0
            };
        }
        const entry = this.cooldowns.get(id)[command.id];
        if (entry.uses >= command.ratelimit) {
            const end = this.cooldowns.get(id)[command.id].end;
            const diff = end - message.createdTimestamp;
            this.emit(Constants_js_1.CommandHandlerEvents.COOLDOWN, message, command, diff);
            return true;
        }
        entry.uses++;
        return false;
    }
    async runCommand(message, command, args) {
        if (!command || !message) {
            this.emit(Constants_js_1.CommandHandlerEvents.COMMAND_INVALID, message, command);
            return;
        }
        const typing = command.typing || this.typing
            ? setInterval(() => {
                if (command.typing || this.typing)
                    message.channel.sendTyping();
            }, 9000)
            : undefined;
        try {
            this.emit(Constants_js_1.CommandHandlerEvents.COMMAND_STARTED, message, command, args);
            const ret = await command.exec(message, args);
            this.emit(Constants_js_1.CommandHandlerEvents.COMMAND_FINISHED, message, command, args, ret);
        }
        finally {
            if (typing)
                clearInterval(typing);
        }
    }
    async parseCommand(message) {
        const allowMention = await (0, Util_js_2.intoCallable)(this.prefix)(message);
        let prefixes = (0, Util_js_2.intoArray)(allowMention);
        if (allowMention) {
            const mentions = [`<@${this.client.user?.id}>`, `<@!${this.client.user?.id}>`];
            prefixes = [...mentions, ...prefixes];
        }
        prefixes.sort(Util_js_2.prefixCompare);
        return this.parseMultiplePrefixes(message, prefixes.map(p => [p, null]));
    }
    async parseCommandOverwrittenPrefixes(message) {
        if (!this.prefixes.size) {
            return {};
        }
        const promises = this.prefixes.map(async (cmds, provider) => {
            const prefixes = (0, Util_js_2.intoArray)(await (0, Util_js_2.intoCallable)(provider)(message));
            return prefixes.map(p => [p, cmds]);
        });
        const pairs = (await Promise.all(promises)).flatMap(x => x, 1);
        pairs.sort(([a], [b]) => (0, Util_js_2.prefixCompare)(a, b));
        return this.parseMultiplePrefixes(message, pairs);
    }
    parseMultiplePrefixes(message, pairs) {
        const parses = pairs.map(([prefix, cmds]) => this.parseWithPrefix(message, prefix, cmds));
        const result = parses.find(parsed => parsed.command);
        if (result) {
            return result;
        }
        const guess = parses.find(parsed => parsed.prefix != null);
        if (guess) {
            return guess;
        }
        return {};
    }
    parseWithPrefix(message, prefix, associatedCommands = null) {
        const lowerContent = message.content.toLowerCase();
        if (!lowerContent.startsWith(prefix.toLowerCase())) {
            return {};
        }
        const endOfPrefix = lowerContent.indexOf(prefix.toLowerCase()) + prefix.length;
        const startOfArgs = message.content.slice(endOfPrefix).search(/\S/) + prefix.length;
        const alias = message.content.slice(startOfArgs).split(/\s{1,}|\n{1,}/)[0];
        const command = this.findCommand(alias);
        const content = message.content.slice(startOfArgs + alias.length + 1).trim();
        const afterPrefix = message.content.slice(prefix.length).trim();
        if (!command) {
            return { prefix, alias, content, afterPrefix };
        }
        if (associatedCommands == null) {
            if (command.prefix != null) {
                return { prefix, alias, content, afterPrefix };
            }
        }
        else if (!associatedCommands.has(command.id)) {
            return { prefix, alias, content, afterPrefix };
        }
        return { command, prefix, alias, content, afterPrefix };
    }
    emitError(err, message, command) {
        if (this.listenerCount(Constants_js_1.CommandHandlerEvents.ERROR)) {
            this.emit(Constants_js_1.CommandHandlerEvents.ERROR, err, message, command);
            return;
        }
        throw err;
    }
    sweepCommandUtil(lifetime = this.commandUtilLifetime) {
        let count = 0;
        for (const commandUtil of this.commandUtils.values()) {
            const now = Date.now();
            const message = commandUtil.message;
            if (now - (message.editedTimestamp || message.createdTimestamp) > lifetime) {
                count++;
                this.commandUtils.delete(message.id);
            }
        }
        return count;
    }
    addPrompt(channel, user) {
        let users = this.prompts.get(channel.id);
        if (!users)
            this.prompts.set(channel.id, new Set());
        users = this.prompts.get(channel.id);
        users?.add(user.id);
    }
    removePrompt(channel, user) {
        const users = this.prompts.get(channel.id);
        if (!users)
            return;
        users.delete(user.id);
        if (!users.size)
            this.prompts.delete(user.id);
    }
    hasPrompt(channel, user) {
        const users = this.prompts.get(channel.id);
        if (!users)
            return false;
        return users.has(user.id);
    }
    findCommand(name) {
        return this.modules.get(this.aliases.get(name.toLowerCase()));
    }
    useInhibitorHandler(inhibitorHandler) {
        this.inhibitorHandler = inhibitorHandler;
        this.resolver.inhibitorHandler = inhibitorHandler;
        return this;
    }
    useListenerHandler(listenerHandler) {
        this.resolver.listenerHandler = listenerHandler;
        return this;
    }
    useTaskHandler(taskHandler) {
        this.resolver.taskHandler = taskHandler;
        return this;
    }
    useContextMenuCommandHandler(contextMenuCommandHandler) {
        this.resolver.contextMenuCommandHandler = contextMenuCommandHandler;
        return this;
    }
}
exports.CommandHandler = CommandHandler;
class RegisterInteractionCommandError extends Error {
    constructor(original, type, data, guild = null) {
        super("Failed to register interaction commands.");
        this.original = original;
        this.type = type;
        this.data = data;
        this.guild = guild;
    }
}
exports.RegisterInteractionCommandError = RegisterInteractionCommandError;
exports.MentionPrefixPredicate = zod_1.z.function().args(Util_js_1.MessageInstance).returns((0, Util_js_1.SyncOrAsync)(zod_1.z.boolean()));
exports.IgnoreCheckPredicate = zod_1.z
    .function()
    .args(zod_1.z.union([Util_js_1.MessageInstance, zod_1.z.instanceof(AkairoMessage_js_1.AkairoMessage)]), Command_js_1.CommandInstance)
    .returns(zod_1.z.boolean());
exports.PrefixSupplier = zod_1.z
    .function()
    .args(Util_js_1.MessageInstance)
    .returns((0, Util_js_1.SyncOrAsync)((0, Util_js_1.ArrayOrNot)(zod_1.z.string())));
exports.CommandHandlerOptions = AkairoHandler_js_1.AkairoHandlerOptions.extend({
    aliasReplacement: zod_1.z.instanceof(RegExp).optional(),
    allowMention: zod_1.z.union([zod_1.z.boolean(), exports.MentionPrefixPredicate]).optional(),
    argumentDefaults: Argument_js_1.DefaultArgumentOptions.optional(),
    autoDefer: zod_1.z.boolean().optional(),
    autoRegisterSlashCommands: zod_1.z.boolean().optional(),
    blockBots: zod_1.z.boolean().optional(),
    blockClient: zod_1.z.boolean().optional(),
    commandUtil: zod_1.z.boolean().optional(),
    commandUtilLifetime: zod_1.z.number().optional(),
    commandUtilSweepInterval: zod_1.z.number().optional(),
    defaultCooldown: zod_1.z.number().optional(),
    fetchMembers: zod_1.z.boolean().optional(),
    handleEdits: zod_1.z.boolean().optional(),
    ignoreCooldown: zod_1.z.union([(0, Util_js_1.ArrayOrNot)(zod_1.z.string()), exports.IgnoreCheckPredicate]).optional(),
    ignorePermissions: zod_1.z.union([(0, Util_js_1.ArrayOrNot)(zod_1.z.string()), exports.IgnoreCheckPredicate]).optional(),
    prefix: zod_1.z.union([(0, Util_js_1.ArrayOrNot)(zod_1.z.string()), exports.PrefixSupplier]).optional(),
    storeMessages: zod_1.z.boolean().optional(),
    typing: zod_1.z.boolean().optional(),
    execSlash: zod_1.z.boolean().optional(),
    skipBuiltInPostInhibitors: zod_1.z.boolean().optional()
}).passthrough();
exports.SlashResolveType = zod_1.z.enum([
    "Attachment",
    "Boolean",
    "Channel",
    "Integer",
    "Member",
    "Mentionable",
    "Number",
    "Role",
    "String",
    "User"
]);
//# sourceMappingURL=CommandHandler.js.map