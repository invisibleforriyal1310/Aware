"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CommandUtil = void 0;
const discord_js_1 = require("discord.js");
const AkairoMessage_js_1 = require("../../util/AkairoMessage.js");
const CommandHandler_js_1 = require("./CommandHandler.js");
class CommandUtil {
    static { this.deletedMessages = new Set(); }
    get deleted() {
        return this.isSlash ? false : CommandUtil.deletedMessages.has(this.message.id);
    }
    constructor(handler, message) {
        this.handler = handler;
        this.message = message;
        this.parsed = null;
        this.shouldEdit = false;
        this.lastResponse = null;
        this.messages = this.handler instanceof CommandHandler_js_1.CommandHandler && this.handler.storeMessages ? new discord_js_1.Collection() : null;
        this.isSlash = this.message instanceof AkairoMessage_js_1.AkairoMessage;
    }
    isSlashMessage(message) {
        return message instanceof AkairoMessage_js_1.AkairoMessage;
    }
    addMessage(message) {
        if (this.handler instanceof CommandHandler_js_1.CommandHandler && this.handler.storeMessages) {
            if (Array.isArray(message)) {
                for (const msg of message) {
                    this.messages?.set(msg.id, msg);
                }
            }
            else {
                this.messages?.set(message.id, message);
            }
        }
        return message;
    }
    async edit(options) {
        if (!this.isSlashMessage(this.message)) {
            return await this.lastResponse.edit(options);
        }
        else {
            return await this.message.interaction.editReply(options);
        }
    }
    async reply(options) {
        const newOptions = (typeof options === "string" ? { content: options } : options);
        if (!this.isSlashMessage(this.message) && !this.shouldEdit && !(newOptions instanceof discord_js_1.MessagePayload) && !this.deleted) {
            newOptions.reply = {
                messageReference: this.message,
                failIfNotExists: newOptions.failIfNotExists ?? this.handler.client.options.failIfNotExists
            };
        }
        return await this.send(newOptions);
    }
    async send(options) {
        const hasFiles = typeof options === "string" || !options.files?.length ? false : options.files.length > 0;
        const newOptions = typeof options === "string" ? { content: options } : options;
        if (!this.isSlashMessage(this.message)) {
            newOptions.ephemeral = undefined;
            if (this.shouldEdit &&
                !hasFiles &&
                !CommandUtil.deletedMessages.has(this.lastResponse.id) &&
                !this.lastResponse.attachments.size) {
                return await this.lastResponse.edit(newOptions);
            }
            const sent = await this.message.channel?.send(newOptions);
            const lastSent = this.setLastResponse(sent);
            this.setEditable(!lastSent.attachments.size);
            return sent;
        }
        else {
            newOptions.reply = undefined;
            if (this.lastResponse || this.message.interaction.deferred || this.message.interaction.replied) {
                this.lastResponse = (await this.message.interaction.editReply(newOptions));
                return this.lastResponse;
            }
            else {
                Object.assign(newOptions, { fetchReply: true });
                this.lastResponse = (await this.message.interaction.reply(newOptions));
                return this.lastResponse;
            }
        }
    }
    async sendNew(options) {
        if (!this.isSlashMessage(this.message)) {
            const sent = await this.message.channel?.send(options);
            const lastSent = this.setLastResponse(sent);
            this.setEditable(!lastSent.attachments.size);
            return sent;
        }
        else {
            const sent = (await this.message.interaction.followUp(options));
            this.setLastResponse(sent);
            return sent;
        }
    }
    setEditable(state) {
        this.shouldEdit = Boolean(state);
        return this;
    }
    setLastResponse(message) {
        if (Array.isArray(message)) {
            this.lastResponse = message.slice(-1)[0];
        }
        else {
            this.lastResponse = message;
        }
        return this.lastResponse;
    }
    async delete() {
        if (this.isSlashMessage(this.message)) {
            return await this.message.interaction.deleteReply();
        }
        else {
            return await this.lastResponse?.delete();
        }
    }
}
exports.CommandUtil = CommandUtil;
//# sourceMappingURL=CommandUtil.js.map